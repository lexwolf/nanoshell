#ifndef CUP_QUASI_STATIC_SOLVERS_H
#define CUP_QUASI_STATIC_SOLVERS_H

#include "../pump.H"

// Quasi-static solver routines extracted from cup.H.
// Note: default arguments must appear only in declarations (inside class nanosphere).

inline double nanosphere::Rabi_frec(double G, double tau2, double E0){

		double omeR = 2.*sqrt(fabs(G)/tau2)*E0*1.e7;
		return omeR;
		
}

inline std::vector<std::pair<double,double>>  nanosphere::cross_sections(char* mdl , char* mtl ,char* hst ,double omemi, double omema, int omeN, char* sol, double rho){

			int omi, ns=0;
			double pG = fabs(G), omeeV, dome  = (omema-omemi)/omeN, lam_nm, lam;
			double Csca, Cext, Cabs, eps_s, eps_b;
			std::complex<double> alph, eps1, eps2, k, n2;
			std::ofstream crsc;

			crsc.open("../data/output/sts/cross_sections.dat");
			crsc<<"# * CROSS SECTIONS * "<<std::endl;
			crsc<<"#"<<std::endl;
			crsc<<"# file generated by ** cup.H ** "<<std::endl;
			crsc<<"#"<<std::endl;
			crsc<<"# PARAMETERS: "<<std::endl;
			crsc<<"# G = "<<pG<<" a = "<<a<<std::endl;
			crsc<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
			crsc<<"# ------------- "<<std::endl;
			crsc<<"# ome (eV)\tCext\tCsca\tCabs\t lam (nm)"<<std::endl;
			crsc<<"#"<<std::endl;
			
			std::vector<std::pair<double,double>> vext;
			if (sol != NULL) {
			eps_s = set_host(sol);
			ns = 1;
			} else  eps_s=0;
			eps_b = set_host(hst);
			double rE;
			lam_nm  = h * cc * 1.e9 / (omeeV * eV2j); // lam in nm
			if (ns == 0){
				eps1 = metal(omeeV);
				eps2 = active(omeeV, eps_b);
				rE   = a;
			}
			if (ns == 1){
				eps1 = active(omeeV, eps_b);
				eps2 = metal(omeeV);
				eps3 = eps_s;
				rE   = a;
			}
			lam = lam_nm / rE; // lam normalized
			n2 = sqrt(eps2);
			k = 2. * M_PI * n2 / lam;

	// 	    std::complex<double> eps1, eps2, m, x, k, n1, n2;
			for (omi = 0; omi <= omeN; omi++){
				omeeV = omemi + omi * dome;
				lam_nm  = h * cc * 1.e9 / (omeeV * eV2j); // lam in nm
				
				alph = polarizability(eps1, eps2);

				double kreal = k.real();
				double kimag = k.imag();

				Cext = ((kreal*kreal - kimag*kimag)/kreal) * alph.imag()
					+ (2.0*kreal*kimag) * alph.real();   // full apparent extension

				Csca = (pow(kreal,4) / (6.0*M_PI)) * std::norm(alph);  
				Cabs = Cext - Csca;
				crsc << "  " << std::setw(11) << std::setprecision(8) << std::setiosflags(std::ios::left | std::ios::fixed) << omeeV <<   // 1 ome (eV)
					"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Cext <<   // 2 Cext
					"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Csca <<   // 3 Csca
					"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Cabs <<   // 4 Cabs
					"\t" << std::setw(11) << std::setiosflags(std::ios::left) << lam_nm << // 5 lam(nm)
					std::endl;

				vext.push_back(std::make_pair(omeeV, Cext));
			}
			return vext;
	    
}

inline std::vector<std::pair<double,std::complex<double>>>  nanosphere::steady_state(char* mdl , char* mtl ,char* hst ,double omemi, double omema, int omeN, char* sol, double rho){

	    int omi, ns=0;
	    double eps_b, eps_s, ome, omeeV, dome  = (omema-omemi)/omeN;

	    if ((sol != NULL)) {
		eps_s=set_host(sol);
		ns=1;
		}
		else eps_s=0;
	    eps_b=set_host(hst);
	    std::complex<double> eps1, eps2, alph;

	    std::vector<std::pair<double,std::complex<double>>> valph;
	    
	    double tau2, gamd, ome_g, eps3, pG = fabs(G), *nv;
	    std::complex<double> GamG, OmeG, GamM, OmeM, *p0, *p1, *p2, **A, detA, *kap, *odv;
	    
	    A = new std::complex<double>*[3];
	    for(int i = 0; i <= 2; i++)
		A[i] = new std::complex<double>[3];
	    
	    kap = new std::complex<double>[3];
	    
		nv = new double[4];

		odv = new std::complex<double> [3];

            std::ofstream stat("../data/output/stationary.dat");
            if (!stat) {
                std::cerr << "Error: Cannot open output file" << std::endl;
                exit(1);
            }
            std::ofstream comp("../data/output/compounds.dat");
            if (!comp) {
                std::cerr << "Error: Cannot open output file" << std::endl;
                exit(1);
            }
            std::ofstream egva("../data/output/eigenvalues.dat");
            if (!egva) {
                std::cerr << "Error: Cannot open output file" << std::endl;
                exit(1);
            }
	    
	    stat<<"# * STATIC * "<<std::endl;
	    stat<<"#"<<std::endl;
	    stat<<"# file generated by ** cup.H ** "<<std::endl;
	    stat<<"#"<<std::endl;
	    stat<<"# PARAMETERS: "<<std::endl;
	    stat<<"# G = "<<pG<<std::endl;
	    stat<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    stat<<"# ------------- "<<std::endl;
	    stat<<"# ome (eV)\treal(alph)\timag(alph)"<<std::endl;
	    stat<<"#"<<std::endl;


	    comp<<"# * COMPONENTS * "<<std::endl;
	    comp<<"#"<<std::endl;
	    comp<<"# file generated by ** cup.H ** "<<std::endl;
	    comp<<"#"<<std::endl;
	    comp<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    comp<<"# ------------- "<<std::endl;
	    comp<<"# ome (eV)\treal(eps1)\timag(eps1)\treal(eps2)\timag(eps2)"<<std::endl;
	    comp<<"#"<<std::endl;
	    
	    egva<<"# * EIGENVALUES * "<<std::endl;
	    egva<<"#"<<std::endl;  
	    egva<<"# file generated by ** cup.H ** "<<std::endl;
	    egva<<"#"<<std::endl;
	    egva<<"# PARAMETERS: "<<std::endl;
	    egva<<"# G = "<<pG<<std::endl;
	    egva<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    egva<<"# ------------- "<<std::endl;
	    egva<<"# ome (eV)\treal(k1)\timag(k1)\treal(k2)\timag(k2)\treal(k3)\timag(k3)\treal(kap_em)\timag(kap_em)"<<std::endl;
	    egva<<"#"<<std::endl;

	    /** STEADY STATE **/
	
		vkap.clear();

	    // normalized variables
	    nv = normalized_variables ();
		tau2 = nv[1];
		gamd = nv[2];
		ome_g = nv[3];
		GamG = set_GamG(G, tau2);

	    for (omi=0; omi<=omeN; omi++){
		omeeV = omemi + omi*dome;
		if (ns == 0){
		    eps1 = metal(omeeV);
		    eps2 = active(omeeV,eps_b);
		    }
		if (ns == 1){
		    eps1 = active(omeeV,eps_b);
		    eps2 = metal(omeeV);
		    eps3 = eps_s;
		    }
		alph = polarizability(eps1, eps2, eps3, rho);
		
		valph.push_back(std::make_pair(omeeV, alph));
		
		stat<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<     // 1 ome
		      "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(alph)<< // 2 Re(alpha_R)
		      "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(alph)<< // 3 Im(alpha_R)
		      std::endl;

		comp<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<     // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(eps1)<< // 2 Re(eps1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(eps1)<< // 3 Im(eps1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(eps2)<< // 4 Re(eps2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(eps2)<< // 5 Im(eps2)
		    std::endl;

		p0 = pcfc0(ceps_inf, eps_b, eps_s, rho);
		p1 = pcfc1(ceps_inf, eps_b, eps_s, rho);
		p2 = pcfc2(ceps_inf, eps_b, eps_s, rho);
		
		ome = omeeV/Ome_p;
		
		odv  = set_ome_dep_vrbls(ome, ome_g, tau2, gamd);

		OmeG = odv[0];
		OmeM = odv[1];
		GamM = odv[2];

		A    = coefficients(OmeG, OmeM, GamG, GamM, p0, p1, p2);
		detA = determinant(A);
		kap  = eigenvalues(A);
		std::complex<double> kap_em(0.0, 0.0);
		for (int i=0; i<3; i++){
			if (real(kap[i]) >= 0){
				kap_em = kap[i];
			}
		}
		
		double maxVal = kap[0].real();
		int    imax = 0;

		for (int i = 1; i < 3; i++) {
			if (kap[i].real() > maxVal) {
				maxVal = kap[i].real();
				imax = i;
				}
			}
		vkap.push_back(std::make_pair(omeeV, kap[imax]));
		egva<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<              // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[0])<<  // 2 Re(kap1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[0])<<  // 3 Im(kap1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[1])<<  // 4 Re(kap2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[1])<<  // 5 Im(kap2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[2])<<  // 6 Re(kap3)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[2])<<  // 7 Im(kap3)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(detA)<<	  // 8 real(detA)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(detA)<<	  // 9 imag(detA)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap_em)<<  // 10 Re(kap_em)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap_em)<<  // 11 Im(kap_em)
		std::endl;
		}
	    return valph;
	    
}

inline std::complex<double> nanosphere::numerical(char* mdl, char* mtl, char* hst,
                               double E0, double omeeV, double T, double tpump,
                               char* sol, double rho, const char* pump_md, bool evolve_N) {

    constexpr int Nsys = 3;
	PumpMode pm = pump_mode(pump_md);
    double eps_b, eps_s, ome, dt;
    double dnormem = 1.e20, dnavr = 0, dnavrm = 1.e20;

    std::vector<std::complex<double>> wave;
    int ns = 0, wb = 0;
    if (sol != NULL) { eps_s = set_host(sol); ns = 1; }
    else eps_s = 0;

    eps_b = set_host(hst);

    int steste = 0;
    std::complex<double> eps1e, eps2e, alph;
    double omep, t, t_ps, tau1, tau2, gamd, ome_g, pG = fabs(G), tildeN;

    // NOTE: GamG is constant, the N dependence enters via GamG * N
    std::complex<double> GamG, OmeG, GamM, OmeM, chiH, chiP;
    std::complex<double> *p0=nullptr, *p1=nullptr, *p2=nullptr, *p3=nullptr, *p=nullptr;
    std::complex<double> po = {0.0, 0.0};
    std::complex<double> dip = {0.0, 0.0};

    double *nv = nullptr;
    std::complex<double> *odv = nullptr;

    std::complex<double> *q = nullptr;
    std::complex<double> **A = nullptr;
    std::complex<double> *B  = nullptr;

    double dpTOT = 0.0, t0 = 0.0;
    double omeR = 0.0;
    int AVE = 0;

    if (T == 0) { T = 100000; steste = 1; }

    std::ofstream dyna("../data/output/numtime.dat");
    if (!dyna) { std::cerr << "Error: Cannot open output file\n"; std::exit(1); }

    std::ofstream fnct("../data/output/numfunc.dat");
    if (!fnct) { std::cerr << "Error: Cannot open output file\n"; std::exit(1); }

    dyna << "# * NUMERICAL *\n#\n# file generated by ** cup.H **\n#\n"
         << "# PARAMETERS:\n"
         << "# G = " << pG << "\n"
         << "# ome = " << omeeV << " eV\n"
         << "# a " << mdl << " model was used for " << mtl << "\n"
         << "# -------------\n"
         << "# t (ps)\treal(alph)\timag(alph)\treal(dip)\timag(dip)\n#\n";

    fnct << "# * NUMERICAL *\n#\n# file generated by ** cup.H **\n#\n"
         << "# PARAMETERS:\n"
         << "# G = " << pG << "\n"
         << "# ome = " << omeeV << " eV\n"
         << "# a " << mdl << " model was used for " << mtl << "\n"
         << "# -------------\n"
         << "# t (ps)\treal(q0)\timag(q0)\treal(q1)\timag(q1)\treal(q2)\timag(q2)\n#\n";

    // --- Setup ---
    omep = eV2j * Ome_p * 2. * M_PI / h;

    nv = normalized_variables();     // returns new double[4]
    tau1 = nv[0];
    tau2 = nv[1];
    gamd = nv[2];
    ome_g = nv[3];

    GamG = set_GamG(G, tau2);

    metal(omeeV); // needed to calculate ceps_inf

    p0 = pcfc0(ceps_inf, eps_b, eps_s, rho); // assume each returns new complex[3]
    p1 = pcfc1(ceps_inf, eps_b, eps_s, rho);
    p2 = pcfc2(ceps_inf, eps_b, eps_s, rho);
    p3 = pcfc3(ceps_inf, eps_b, eps_s, rho);

    p = (ns == 1) ? p3 : p0;

    ome = omeeV / Ome_p;

    odv = set_ome_dep_vrbls(ome, ome_g, tau2, gamd); // returns new complex[3]
    OmeG = odv[0];
    OmeM = odv[1];
    GamM = odv[2];

    chiH = -GamG / OmeG;
    chiP = -GamM / OmeM;

    eps1e = ceps_inf + chiP;
    eps2e = eps_b   + chiH;

    // time normalization
    T = T * omep * 1.e-12;
    dt = 1.;

    q = new std::complex<double>[Nsys]{0.0, 0.0, 0.0};

    int Nt = static_cast<int>(T / dt);
    int Nprint_max = 50000;                 // keep your original numerical cap
    int iprint = std::max(1, Nt / Nprint_max);

    // Helper to build A,B for current N
    auto rebuild_AB = [&](double N_now) {
        // free old
        if (A) { for(int r=0;r<Nsys;++r) delete[] A[r]; delete[] A; A=nullptr; }
        delete[] B; B=nullptr;

        A = coefficients(OmeG, OmeM, GamG * N_now, GamM, p0, p1, p2);
        B = inhomogeneous(GamG * N_now, GamM, E0, p0, p1, p2);
    };

    // --- Integration loop ---
    double tNmin = 0.0;
	double tNmax = 1.0;

    double N;
    omeR = Rabi_frec(G, tau2, E0);

    int i = 0;

    while (i <= Nt) {
        t = i * dt;
        t_ps = t * 1.e+12 / omep; // time in picoseconds
        i++;

		tildeN = gimme_tildeN(t_ps, tpump, pm, tNmin, tNmax);

		if (evolve_N) {
			if (ns==1) {
				po = numerical_output(E0, q, p0);
				N  = Runge_Kutta_mono_4(N, -1./tau1, tildeN/tau1 + imag(q[0]*conj(po)), dt);
			} else {
				N  = Runge_Kutta_mono_4(N, -1./tau1, tildeN/tau1, dt);
			}
		} else {
			N = tildeN;
		}

        rebuild_AB(N);
        Runge_Kutta_4(q, A, B, dt, Nsys);

        dnormem = steste * norm(dip);
        dip  = numerical_output(E0, q, p);
        alph = dip / E0;

        if (i % iprint == 0) {
            dyna << "  " << std::setw(8) << std::setiosflags(std::ios::left) << t_ps
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(alph)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(alph)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(dip)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(dip)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << N
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(dip - E0)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(dip - E0)
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left)
                 << joule_heating(ns, ome, (dip - E0), q[2])
                 << "\n";

            fnct << "  " << std::setw(8) << std::setiosflags(std::ios::left) << t_ps
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(q[0])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(q[0])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(q[1])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(q[1])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << real(q[2])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << imag(q[2])
                 << "\t" << std::setw(13) << std::setiosflags(std::ios::left) << N
                 << "\n";
        }

        if (t_ps > 2.*tpump) {
            if (steste == 1 && fabs((norm(dip)-dnormem)/norm(dip)) < 1.e-30) break;
            if (fabs((norm(dip)-dnormem)/norm(dip)) < 1.e-10) wb = 1;

            if (wb == 1) wave.push_back(q[0]);

            if (steste == 1 && dnavr != 0.0 && fabs((dnavr-dnavrm)/dnavr) < 1.e-7) break;

            if (AVE == 0) { t0 = t; AVE = 1; }
            dpTOT += norm(dip);

            if (t - t0 >= 1000/omeR) {
                dnavrm = dnavr;
                dnavr  = dpTOT / (t - t0);
                AVE = 0;
                dpTOT = 0;
            }
        }

        if (wave.size() >= 150000) {
            wave.erase(wave.begin(), wave.begin() + 50000);
        }
    }

    if (ns == 1) {
        if (!wave.empty()) nOme = find_Ome_fourier((int)wave.size(), wave, dt, no_fourier_dump());
        else nOme = 0.;
    }

    wave.clear();

    // --- cleanup ---
    if (A) { for(int r=0;r<Nsys;++r) delete[] A[r]; delete[] A; }
    delete[] B;
    delete[] q;

    delete[] p0;
    delete[] p1;
    delete[] p2;
    delete[] p3;

    delete[] nv;
    delete[] odv;

    return dip;

}

inline std::complex<double> nanosphere::analytical(char* mdl , char* mtl ,char* hst,
								double E0, double omeeV, double T, double tpump,
								char* sol, double rho){

		double eps_b, eps_s, ome, dt, dnormem=1.e20;
    		if ((sol != NULL)) eps_s=set_host(sol);
		    else eps_s=0;
		eps_b=set_host(hst);
		int steste=0, amp=0;
		std::complex<double> eps1e, eps2e, eps1, eps2, alph;
		double omep, t, t_ps, tau1, tau2, gamd, ome_g, pG = fabs(G), *nv, N, tildeN;
		std::complex<double> GamGxN, OmeG, chiH, GamM, OmeM, chiP, *p0, *p1, *p2, *p3, *p, *q, *odv;
		
		std::complex<double> dip = {0.0, 0.0};
		std::complex<double> **A = nullptr;
		std::complex<double> *B  = nullptr;
		std::complex<double> *qss = nullptr;
		std::complex<double> *kap = nullptr;
		std::complex<double> **EVE = nullptr;
		std::complex<double> *C = nullptr;

		auto rebuild_linear_system = [&](double N_now){
			GamGxN = set_GamG(G*N_now, tau2);

			// free old A,B,qss,kap,EVE,C
			if (A) { for(int r=0; r<Nsys; ++r) delete[] A[r]; delete[] A; A=nullptr; }
			delete[] B;   B=nullptr;
			delete[] qss; qss=nullptr;
			delete[] kap; kap=nullptr;
			free_evec(EVE, Nsys); EVE=nullptr;
			delete[] C;   C=nullptr;

			A   = coefficients(OmeG, OmeM, GamGxN, GamM, p0, p1, p2);
			B   = inhomogeneous(GamGxN, GamM, E0, p0, p1, p2);
			qss = steady_state_solution(A, B);

			eigen_decomposition(A, kap, EVE, Nsys);
		};
		
		if (T==0){ 
		    T=100000;
		    steste=1;
		    }
		
                std::ofstream dyna("../data/output/anltime.dat");
                if (!dyna) {
                    std::cerr << "Error: Cannot open output file" << std::endl;
                    exit(1);
                }
                std::ofstream fnct("../data/output/anlfunc.dat");
                if (!fnct) {
                    std::cerr << "Error: Cannot open output file" << std::endl;
                    exit(1);
                }
		
		dyna<<"# * ANALYTICAL * "<<std::endl;
		dyna<<"#"<<std::endl;
		dyna<<"# file generated by ** cup.H ** "<<std::endl;
		dyna<<"#"<<std::endl;
		dyna<<"# PARAMETERS: "<<std::endl;
		dyna<<"# G = "<<pG<<std::endl;
		dyna<<"# ome = "<<omeeV<<" eV"<<std::endl;
		dyna<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
		dyna<<"# ------------- "<<std::endl;
		dyna<<"# t (ps)\treal(alph)\timag(alph)\treal(dip)\timag(dip)"<<std::endl;
		dyna<<"#"<<std::endl;

		fnct<<"# * ANALYTICAL * "<<std::endl;
		fnct<<"#"<<std::endl;
		fnct<<"# file generated by ** cup.H ** "<<std::endl;
		fnct<<"#"<<std::endl;
		fnct<<"# PARAMETERS: "<<std::endl;
		fnct<<"# G = "<<pG<<std::endl;
		fnct<<"# ome = "<<omeeV<<" eV"<<std::endl;
		fnct<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
		fnct<<"# ------------- "<<std::endl;
		fnct<<"# t (ps)\treal(q0)\timag(q0)\treal(q1)\timag(q1)\treal(q2)\timag(q2)"<<std::endl;
		fnct<<"#"<<std::endl;

		omep = eV2j*Ome_p*2.*M_PI/h;// omep = eV2j*Ome_p/h;  //converto in Hz
		// normalized variables
		nv = normalized_variables ();
		tau1 = nv[0];
		tau2 = nv[1];
		gamd = nv[2];
		ome_g = nv[3];
	
		metal(omeeV); //needed to calculate ceps_inf
		p0 = pcfc0(ceps_inf, eps_b, eps_s, rho);
		p1 = pcfc1(ceps_inf, eps_b, eps_s, rho);
		p2 = pcfc2(ceps_inf, eps_b, eps_s, rho);
		p3 = pcfc3(ceps_inf, eps_b, eps_s, rho);
		if ((sol != NULL)) p=p3;
		    else p=p0;
		ome = omeeV/Ome_p;
		
			
		odv  = set_ome_dep_vrbls(ome, ome_g, tau2, gamd);
		
		OmeG = odv[0];
		OmeM = odv[1];
		GamM = odv[2];

		// ANALYTICAL SOLUTIONS
		T=T*omep*1.e-12; // in ome_p
		// Initial conditions
		dt  = 1.;
		
		q = new std::complex<double>[3]{0.0, 0.0, 0.0};  // PDF order, fully initialized

		int Nt = static_cast<int>(T/dt);
		int Nprint_max = 500000;
		int iprint = std::max(1, Nt / Nprint_max);

		// let's begin without pump
		tildeN = 0.0;
		N      = tildeN;

		rebuild_linear_system(N);
		C = find_constants(EVE, qss, q, 3);
		double t0 = 0.;
		int i=0, pip=0;
		while (i<=Nt){
		    t=i*dt;
		    t_ps = t * 1.e+12 / omep; // time in picoseconds
		    i++;
		    if(t_ps >= tpump && pip ==0) {
				// the pump is switched on at t = tpump
				tildeN = 1.;
				t0  = t;
				pip = 1.;
				std::complex<double> q_at_t0[3] = { q[0], q[1], q[2] };
				rebuild_linear_system(tildeN);
				C = find_constants(EVE, qss, q_at_t0, 3);
				amp = 0;
				for (int ei=0; ei<3; ++ei) {
					if (kap[ei].real() > 0) { amp = 1; break; }
				}
			}
		    N   = tildeN*(1.-exp(-(t-t0)/(tau1)));
		    for(int ii = 0; ii <= 2; ii++)
				q[ii]   = qss[ii] + C[0]*EVE[ii][0]*exp(kap[0]*(t-t0))
								  + C[1]*EVE[ii][1]*exp(kap[1]*(t-t0))
								  + C[2]*EVE[ii][2]*exp(kap[2]*(t-t0));
    
		    dnormem = steste*norm(dip);
		    dip = numerical_output(E0, q, p);
		    alph = dip/E0;
		    
		    if(i%iprint==0){
				dyna<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<t_ps<<   // 1 time (ps)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<real(alph)<<   // 2 Re(alpha)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<imag(alph)<<   // 3 Im(alpha)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<real(dip)<<    // 4 Re(dip)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<imag(dip)<<    // 5 Im(dip)
					std::endl;
				fnct<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<t_ps<<   // 1 time (ps)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<real(q[0])<<   // 2 Re(q0)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<imag(q[0])<<   // 3 Im(q0)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<real(q[1])<<   // 4 Re(q1)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<imag(q[1])<<   // 5 Im(q1)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<real(q[2])<<   // 6 Re(q2)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<imag(q[2])<<   // 7 Im(q2)
					"\t"<<std::setw(13)<<std::setiosflags (std::ios::left)<<N<<            // 8 Im(q2)
					std::endl;
				}
			if (amp == 1 && norm(dip)/E0 > 5.e26) break;
			if (amp == 0 && t_ps>2.*tpump) 
				if (fabs((norm(dip)-dnormem)/norm(dip)) < 1.e-20) break;
		    }

		free_evec(EVE, 3);   // deletes EVE rows + EVE
		delete[] kap;
		delete[] qss;
		delete[] C;
		delete[] B;

		if (A) { for(int r=0; r<3; ++r) delete[] A[r]; delete[] A; }

		delete[] nv;
		delete[] odv;

		delete[] q;
		delete[] p0;
		delete[] p1;
		delete[] p2;
		delete[] p3;
		return dip;
		
}



#endif // CUP_QUASI_STATIC_SOLVERS_H
