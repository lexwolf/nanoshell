#pragma once

#include "nano_geo_matrix/cup/pump.hpp"

// includes
#include "nano_geo_matrix/mie/geometry/gimme_p.hpp"
#include "nano_geo_matrix/mie/geometry/single.hpp"


// Mie backend solvers & observables extracted from cupN.H.
// Provides out-of-class inline definitions of nanosphere member functions.

inline double nanosphere::Rabi_frec(double G, double tau2, double E0){
		double omeR = 2.*sqrt(fabs(G)/tau2)*E0*1.e7;
		return omeR;
		}

	std::pair<double,double>  nanosphere::mie_cs(int orders, double omeeV ,char* mdl , char* mtl ,char* hst , char* sol, double rho){
		std::pair<double,double> CC;
		int ns=0;
		std::vector<std::complex <double>> a, b;
		double eps_b, eps_s, eps3=0., lam, lam_nm;
		double Csca, Cext;
	
		if (sol != NULL) {
			eps_s = set_host(sol);
			ns = 1;
		} else {
			eps_s = 0;
		}
		eps_b = set_host(hst);
		std::complex<double> eps1, eps2, m, x, k, n1, n2;
		double rE;
		lam_nm  = h * cc * 1.e9 / (omeeV * eV2j); // lam in nm
		if (ns == 0){
			eps1 = metal(omeeV);
			eps2 = active(omeeV, eps_b);
			rE   = this->a;
		}
		if (ns == 1){
			eps1 = active(omeeV, eps_b);
			eps2 = metal(omeeV);
			eps3 = eps_s;
			rE   = this->a;
		}
		lam = lam_nm / rE; // lam normalized
		n2 = sqrt(eps2);
		k = 2. * M_PI * n2 / lam;
		#ifdef USE_MYBESSEL_SPECIAL
			// If USE_MYBESSEL_SPECIAL is defined, compute all coefficients at once.
			auto mieCoeffs = mie_coefficients(orders, eps1, eps2, eps3, rho, lam);
			for (int ii = 0; ii <= orders; ++ii) {
				a.push_back(mieCoeffs[ii].first);
				b.push_back(mieCoeffs[ii].second);
			}
		#else
			// Otherwise, fall back to computing each coefficient individually.
			for (int ii = 0; ii <= orders; ++ii) {
				auto mie_result = mie_coefficient(ii, eps1, eps2, eps3, rho, lam);
				a.push_back(mie_result.first);
				b.push_back(mie_result.second);
			}
		#endif	
		Csca = 0;
		Cext = 0;
		for (int n = 1; n <= orders; n++){
			Cext += (2 * n + 1) * real((a[n] + b[n])/k);
			Csca += (2 * n + 1) * norm(a[n] + b[n]);
		}
		Csca = (2 * M_PI / (norm(k))) * Csca;
		Cext = (2 * M_PI / (real(k))) * Cext;
		// current results are normalized to a^2, in order to have them normalized to pi*a^2:
		Csca = M_PI * Csca;
		Cext = M_PI * Cext;
		CC = std::make_pair(Cext, Csca);
		return CC;
	}

inline std::vector<std::pair<double,double>>  nanosphere::cross_sections(int orders, char* mdl , char* mtl ,char* hst ,double omemi, double omema, int omeN, char* sol, double rho){
	    int omi;//, ns=0;
// 	    double eps_b, eps_s, eps3=0., 
		double pG = fabs(G), omeeV, dome  = (omema-omemi)/omeN, lam_nm;//, lam
	    std::vector<std::complex <double>> a, b;
	    double Csca, Cext, Cabs;
		std::pair<double,double> CC;
	    std::ofstream crsc;

	    crsc.open("../data/output/sts/cross_sections.dat");
	    crsc<<"# * CROSS SECTIONS * "<<std::endl;
	    crsc<<"#"<<std::endl;
	    crsc<<"# file generated by ** cup.H ** "<<std::endl;
	    crsc<<"#"<<std::endl;
	    crsc<<"# PARAMETERS: "<<std::endl;
	    crsc<<"# G = "<<pG<<" a = "<<this->a<<std::endl;
	    crsc<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    crsc<<"# ------------- "<<std::endl;
	    crsc<<"# ome (eV)\tCext\tCsca\tCabs\t lam (nm)"<<std::endl;
	    crsc<<"#"<<std::endl;

	    std::vector<std::pair<double,double>> vext;
// 	    if (sol != NULL) {
// 		eps_s = set_host(sol);
// 		ns = 1;
// 		} else {
// 		    eps_s = 0;
// 		    }
// 	    eps_b = set_host(hst);
// 	    std::complex<double> eps1, eps2, m, x, k, n1, n2;
	    for (omi = 0; omi <= omeN; omi++){
		omeeV = omemi + omi * dome;
		lam_nm  = h * cc * 1.e9 / (omeeV * eV2j); // lam in nm

		CC = mie_cs(orders, omeeV , mdl , mtl , hst);
		Cext = CC.first;
		Csca = CC.second;
		Cabs = Cext - Csca;
		crsc << "  " << std::setw(11) << std::setprecision(8) << std::setiosflags(std::ios::left | std::ios::fixed) << omeeV <<   // 1 ome (eV)
			"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Cext <<   // 2 Cext
			"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Csca <<   // 3 Csca
			"\t" << std::setw(11) << std::setiosflags(std::ios::left) << Cabs <<   // 4 Cabs
			"\t" << std::setw(11) << std::setiosflags(std::ios::left) << lam_nm << // 5 lam(nm)
			std::endl;

		vext.push_back(std::make_pair(omeeV, Cext));
		a.clear();
		b.clear();
		}
	    return vext;
	    }

inline std::vector<std::pair<double,std::complex<double>>>  nanosphere::steady_state(int order, char* mdl , char* mtl ,char* hst ,double omemi, double omema, int omeN, char* sol, double rho){
	    int omi, ns=0;
	    double eps_b, eps_s, ome, omeeV, dome  = (omema-omemi)/omeN;
	    vkap.clear();
	    if ((sol != NULL)) {
		eps_s=set_host(sol);
		ns=1;
		}
		else eps_s=0;
	    eps_b=set_host(hst);
	    std::complex<double> eps1, eps2, aj, bj, alph, m, x, k, n1, n2, *p0, *p1, *p2, *p3, detA;

	    std::vector<std::pair<double,std::complex<double>>> vaj;

	    double tau2, gamd, ome_g, eps3, pG = fabs(G), *nv, lam;
	    std::complex<double> GamG, OmeG, GamM, OmeM, **A, *kap, **EVE, *odv;

	    A = new std::complex<double>*[5];
	    for(int i = 0; i < 5; i++)
		A[i] = new std::complex<double>[5];

	    kap = new std::complex<double>[5];
		EVE = new std::complex<double>*[5];
		for(int i = 0; i < 5; i++)
		    EVE[i] = new std::complex<double>[5];
		nv = new double[4];

		odv = new std::complex<double> [3];

        std::ostringstream egvaname;
		egvaname << "../data/output/sts/eigenvalues/ev" << std::setw(2) << std::setfill('0') << order << ".dat";
        std::ostringstream cffcname;
		cffcname << "../data/output/sts/coefficients/a" << std::setw(2) << std::setfill('0') << order << ".dat";
        std::ostringstream cffcnbme;
		cffcnbme << "../data/output/sts/coefficients/b" << std::setw(2) << std::setfill('0') << order << ".dat";

	std::ofstream egva(egvaname.str());
	std::ofstream cffc(cffcname.str());
	std::ofstream cffb(cffcnbme.str());
	std::ofstream comp;
	std::ofstream stat;
	std::ofstream heiv;
	heiv.open("../data/output/sts/highest_ev.dat");
	if (order == 1){
	    stat.open("../data/output/sts/stationary.dat");
		stat<<"# * STATIC * "<<std::endl;
		stat<<"#"<<std::endl;
		stat<<"# file generated by ** cup.H ** "<<std::endl;
		stat<<"#"<<std::endl;
		stat<<"# PARAMETERS: "<<std::endl;
		stat<<"# G = "<<pG<<" a = "<<this->a<<std::endl;
		stat<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
		stat<<"# ------------- "<<std::endl;
		stat<<"# ome (eV)\treal(alph)\timag(alph)"<<std::endl;
		stat<<"#"<<std::endl;
	    }

	    cffc<<"# * MIE COEFFICIENT * "<<std::endl;
	    cffc<<"#"<<std::endl;
	    cffc<<"# file generated by ** cup.H ** "<<std::endl;
	    cffc<<"#"<<std::endl;
	    cffc<<"# PARAMETERS: "<<std::endl;
	    cffc<<"# G = "<<pG<<" a = "<<this->a<<std::endl;
	    cffc<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    cffc<<"# ------------- "<<std::endl;
	    cffc<<"# ome (eV)\treal(a["<<order<<"])\timag(a["<<order<<"])"<<std::endl;
	    cffc<<"#"<<std::endl;

        comp.open("../data/output/sts/compounds.dat");
	    comp<<"# * COMPONENTS * "<<std::endl;
	    comp<<"#"<<std::endl;
	    comp<<"# file generated by ** cup.H ** "<<std::endl;
	    comp<<"#"<<std::endl;
	    comp<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    comp<<"# ------------- "<<std::endl;
	    comp<<"# ome (eV)\treal(eps1)\timag(eps1)\treal(eps2)\timag(eps2)"<<std::endl;
	    comp<<"#"<<std::endl;

	    egva<<"# * EIGENVALUES * "<<std::endl;
	    egva<<"#"<<std::endl;  
	    egva<<"# file generated by ** cup.H ** "<<std::endl;
	    egva<<"#"<<std::endl;
	    egva<<"# PARAMETERS: "<<std::endl;
	    egva<<"# G = "<<pG<<" a = "<<this->a<<std::endl;
	    egva<<"# a "<<mdl<<" model was used for "<<mtl<<std::endl;
	    egva<<"# ------------- "<<std::endl;
	    egva<<"# ome (eV)\treal(k1)\timag(k1)\treal(k2)\timag(k2)\treal(k3)\timag(k3)\treal(k4)\timag(k4)\treal(k5)\timag(k5)\treal(detA)\timag(detA)"<<std::endl;
	    egva<<"#"<<std::endl;

	    /** STEADY STATE **/

	    // normalized variables
	    nv = normalized_variables ();
		tau2 = nv[1];
		gamd = nv[2];
		ome_g = nv[3];
		GamG = set_GamG(G, tau2);

	    for (omi=0; omi<=omeN; omi++){
		omeeV = omemi + omi*dome;
		if (ns == 0){
		    eps1 = metal(omeeV);
		    eps2 = active(omeeV,eps_b);
		    }
		if (ns == 1){
		    eps1 = active(omeeV,eps_b);
		    eps2 = metal(omeeV);
		    eps3 = eps_s;
		    }


		lam = h*cc*1.e9/(omeeV*eV2j); // lam in nm
		lam = lam/this->a;                // lam normalized

		aj  = mie_coefficient(order, eps1,eps2, eps3, rho, lam).first;
		bj  = mie_coefficient(order, eps1,eps2, eps3, rho, lam).second;
		vaj.push_back(std::make_pair(omeeV, aj));

		cffc<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<   // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(aj)<< // 2 Re(aj)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(aj)<< // 3 Im(aj)
		    std::endl;


		cffb<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<   // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(bj)<< // 2 Re(bj)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(bj)<< // 3 Im(bj)
		    std::endl;

		if (order==1){
		    alph = polarizability(aj,eps2, lam);
		    stat<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<     // 1 ome
			"\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(alph)<< // 2 Re(alpha_R)
			"\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(alph)<< // 3 Im(alpha_R)
			std::endl;
		    }

		comp<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<     // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(eps1)<< // 2 Re(eps1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(eps1)<< // 3 Im(eps1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(eps2)<< // 4 Re(eps2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(eps2)<< // 5 Im(eps2)
		    std::endl;

		n1=sqrt(eps1);
		n2=sqrt(eps2);
		m=n1/n2;

		lam = h*cc/(omeeV*eV2j);
		lam =lam/(this->a*1.e-9);
		k = 2.*M_PI*n2/lam;
		x = k;

		ome = omeeV/Ome_p;
		odv  = set_ome_dep_vrbls(ome, ome_g, tau2, gamd);

		OmeG = odv[0];
		OmeM = odv[1];
		GamM = odv[2];

		p0 = pcfc0(order, x, m, ceps_inf, eps_b, GamG, OmeG, GamM, OmeM, ome, eps_s, rho);
		p1 = pcfc1(order, x, m, ceps_inf, eps_b, GamG, OmeG, GamM, OmeM, ome, eps_s, rho);
		p2 = pcfc2(order, x, m, ceps_inf, eps_b, GamG, OmeG, GamM, OmeM, ome, eps_s, rho);
		p3 = pcfc3(order, x, m, ceps_inf, eps_b, GamG, OmeG, GamM, OmeM, ome, eps_s, rho);

		A   = coefficients(OmeG, OmeM, GamG, GamM, p0, p1, p2, p3);  

		kap  = eigenvalues(A, 5);
 		EVE  = eigenvectors(A, 5);
		detA = determinant(A, 5);

		// double maxVal = kap[0].real();
		// int    imax = 0;
		// for (int i = 1; i < 5; i++) {
		// 	if (kap[i].real() > maxVal) {
		// 		maxVal = kap[i].real();
		// 		imax = i;
		// 		}
		// 	}
		int imax = -1;

		const double EVE_THRESHOLD = 1e-30;   // can be relaxed/tightened later

		// Step 1: sort eigenvalue indices by decreasing Re(kap[j])
		std::vector<int> indices(5);
		std::iota(indices.begin(), indices.end(), 0);
		std::sort(indices.begin(), indices.end(), [&](int a, int b) {
			return kap[a].real() > kap[b].real();
		});

		// Step 2: scan modes
		for (int idx = 0; idx < 5; ++idx) {
			int jtent = indices[idx];
			bool valid = false;

			for (int ii = 0; ii < 5; ++ii) {
				if (std::norm(p0[ii]) > 0.0) {  // only consider physically relevant components
					if (std::norm(EVE[ii][jtent]) > EVE_THRESHOLD) {
						valid = true;
						break;
					}
				}
			}

			if (valid) {
				imax = jtent;
				break;
			}
		}

		if (imax >= 0) vkap.push_back({omeeV, kap[imax]});

		// // Output
		// if (imax >= 0) {
		// 	std::cout << "Accepted emission mode j = " << imax
		// 			<< " with Re(kap) = " << kap[imax].real() << std::endl;
		// 	vkap.push_back({omeeV, kap[imax]});
		// } else {
		// 	std::cout << "No valid emission mode found at this frequency." << std::endl;
		// }

		// vkap.push_back(std::make_pair(omeeV, kap[imax]));

		heiv<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<              // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(kap[imax])<<
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(kap[imax])<<
		std::endl;

		egva<<"  "<<std::setw(8)<<std::setiosflags (std::ios::left)<<omeeV<<              // 1 ome
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[0])<<  // 2 Re(kap1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[0])<<  // 3 Im(kap1)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[1])<<  // 4 Re(kap2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[1])<<  // 5 Im(kap2)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[2])<<  // 6 Re(kap3)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[2])<<  // 7 Im(kap3)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[3])<<  // 8 Re(kap4)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[3])<<  // 9 Im(kap4)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*real(kap[4])<<  //10 Re(kap5)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<Ome_p*imag(kap[4])<<  //11 Im(kap5)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<real(detA)<<	  //12 Re(detA)
		    "\t"<<std::setw(11)<<std::setiosflags (std::ios::left)<<imag(detA)<<	  //13 Im(detA)
		std::endl;
		}
	    return vaj;
	    }

inline std::complex<double> nanosphere::numerical(int order, char* mdl , char* mtl ,char* hst,
								double E0, double omeeV, double T, double tpump,
								char* sol, double rho, const char* pump_md, bool evolve_N){
		constexpr int Nsys = 5;
		PumpMode pm = pump_mode(pump_md);
		double eps_b, eps_s, ome, dt, dnormem=1.e20, dnavr=0, dnavrm=1.e20, tildeN;
		std::vector<std::complex<double>> wave;

		int ns = 0;
		if (sol != NULL) { eps_s = set_host(sol); ns = 1; }
		else             { eps_s = 0; }

		eps_b = set_host(hst);
		int steste = 0;

		std::complex<double> eps1e, eps2e, eps1, eps2, alph, m, x, k,
							*p=nullptr, *p0=nullptr, *p1=nullptr, *p2=nullptr, *p3=nullptr, n1, n2;

		double omep, t, t_ps, tau1, tau2, gamd, lam, ome_g, pG = fabs(G);
		double *nv = nullptr;

		std::complex<double> GamGxN, OmeG, chiH,
							GamM, OmeM, chiP, **A=nullptr, *B=nullptr, aj, po, *odv=nullptr;

		double dpTOT=0, t0=0;
		double omeR=0;
		int AVE=0;

		if (T==0) { T=100000; steste=1; }

		std::ostringstream fncname, aj_name;
		fncname << "../data/output/num/func" << std::setw(2) << std::setfill('0') << order << ".dat";
		aj_name << "../data/output/num/a"    << std::setw(2) << std::setfill('0') << order << ".dat";

		std::ofstream fnct(fncname.str());
		std::ofstream a_aj(aj_name.str());
		std::ofstream dyna;

		if(order==1){
			dyna.open("../data/output/numtime.dat");
			dyna<<"# * NUMERICAL *\n#\n# file generated by ** cupN.H **\n#\n";
			dyna<<"# PARAMETERS:\n";
			dyna<<"# G = "<<pG<<" a = "<<this->a<<"\n";
			dyna<<"# ome = "<<omeeV<<" eV\n";
			dyna<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
			dyna<<"# -------------\n";
			dyna<<"# t (ps)\treal(alph)\timag(alph)\n#\n";
		}

		fnct<<"# * NUMERICAL *\n#\n# file generated by ** cupN.H **\n#\n";
		fnct<<"# PARAMETERS:\n";
		fnct<<"# G = "<<pG<<" a = "<<this->a<<"\n";
		fnct<<"# ome = "<<omeeV<<" eV\n";
		fnct<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
		fnct<<"# -------------\n";
		fnct<<"# t (ps)\treal(q0)\timag(q0)\treal(q1)\timag(q1)\treal(q2)\timag(q2)\treal(q4)\timag(q4)\n#\n";

		a_aj<<"# * NUMERICAL *\n#\n# file generated by ** cupN.H **\n#\n";
		a_aj<<"# PARAMETERS:\n";
		a_aj<<"# G = "<<pG<<" a = "<<this->a<<"\n";
		a_aj<<"# ome = "<<omeeV<<" eV\n";
		a_aj<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
		a_aj<<"# -------------\n";
		a_aj<<"# t (ps)\treal(a"<<order<<")\timag(a"<<order<<")\n#\n";

		// --- helpers ---------------------------------------------------------
		auto free_matrix = [&](std::complex<double>**& M, int n){
			if (!M) return;
			for (int i=0;i<n;++i) delete[] M[i];
			delete[] M;
			M = nullptr;
		};
		auto free_vec = [&](std::complex<double>*& v){
			delete[] v;
			v = nullptr;
		};
		auto free_pcfc = [&](){
			delete[] p0; p0=nullptr;
			delete[] p1; p1=nullptr;
			delete[] p2; p2=nullptr;
			delete[] p3; p3=nullptr;
			p = nullptr;
		};

		auto rebuild_medium = [&](double Nnow){
			// active medium (scaled at GamG level)
			GamGxN = set_GamG(G*Nnow, tau2);
			chiH   = -GamGxN/OmeG;
			eps2e  = eps_b + chiH;
			eps2   = eps2e;                 // keep consistent with gain implementation

			n2 = sqrt(eps2e);
			m  = n1/n2;

			k = 2.*M_PI*n2/lam;
			x = k;

			free_pcfc();
			p0 = pcfc0(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p1 = pcfc1(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p2 = pcfc2(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p3 = pcfc3(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);

			p = (ns==1) ? p3 : p0;
		};

		auto rebuild_linear_system = [&](){
			free_matrix(A, Nsys);
			free_vec(B);

			A = coefficients(OmeG, OmeM, GamGxN, GamM, p0, p1, p2, p3);
			B = inhomogeneous(GamGxN, GamM, E0, p0, p1, p2, p3);
		};

		// --- physics setup ---------------------------------------------------
		omep = eV2j*Ome_p/h;  // Hz

		nv   = normalized_variables();
		tau1 = nv[0];
		tau2 = nv[1];
		gamd = nv[2];
		ome_g = nv[3];

		ome = omeeV/Ome_p;

		odv  = set_ome_dep_vrbls(ome, ome_g, tau2, gamd);
		OmeG = odv[0];
		OmeM = odv[1];
		GamM = odv[2];

		// metal part
		eps1  = metal(omeeV);
		chiP  = -GamM/OmeM;
		eps1e = ceps_inf + chiP;
		n1    = sqrt(eps1e);

		lam = h*cc/(omeeV*eV2j);
		lam = lam/(this->a*1.e-9);

		// time normalization
		T  = T*omep*1.e-12;
		dt = 1.;

		std::complex<double>* q = new std::complex<double>[Nsys]{};

		int Nt = static_cast<int>(T/dt);
		int Nprint_max = 500000;
		int iprint = std::max(1, Nt / Nprint_max);

		double tNmin = 0.0;
		double tNmax = 1.0;

		double N = tNmin;
		rebuild_medium(N);
		rebuild_linear_system();
		omeR = Rabi_frec(G, tau2, E0);

		int i=0;
		while (i<=Nt){
			t=i*dt;
			t_ps = t * 1.e+12 / omep; // time in picoseconds
			++i;
		
			tildeN = gimme_tildeN(t_ps, tpump, pm, tNmin, tNmax);
			if (evolve_N) {
				if (ns==1) {
					po = numerical_output(E0, q, p0);
					N  = Runge_Kutta_mono_4(N, -1./tau1, tildeN/tau1 + imag(q[0]*conj(po)), dt);
				} else {
					N  = Runge_Kutta_mono_4(N, -1./tau1, tildeN/tau1, dt);
				}
			} else {
				N = tildeN;
			}

			rebuild_medium(N);
			rebuild_linear_system();

			Runge_Kutta_4(q, A, B, dt, Nsys);

			dnormem = steste*norm(aj);
			aj = numerical_output(E0, q, p)/E0;

			if (order==1) alph = polarizability(aj, eps2, lam);
			else          alph = {0,0};

				if(i%iprint==0){
					if(order==1)
						dyna<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
							<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(alph)
							<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(alph)
							<<"\n";

					a_aj<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(aj)
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(aj)
						<<"\n";

					fnct<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[0])
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[0])
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[1])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[1])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[2])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[2])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[3])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[3])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[4])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[4])
					<<"\n";
			}

			if (t_ps > 2.*tpump){
				if (fabs((norm(aj)-dnormem)/norm(aj)) < 1.e-20 && steste==1) break;

				if (fabs((norm(aj)-dnormem)/norm(aj)) < 1.e-10) wave.push_back(q[0]);

				if (fabs((dnavr-dnavrm)/dnavr) < 1.e-6 && steste==1) break;

				if (AVE==0){ t0=t; AVE=1; }
				dpTOT += norm(aj);

				omeR = Rabi_frec(G*N, tau2, E0);
				if (t-t0 >= 1000/omeR){
					dnavrm=dnavr;
					dnavr=dpTOT/(t-t0);
					AVE=0;
					dpTOT =0;
				}
			}

			if (wave.size()>=150000) wave.erase(wave.begin(), wave.begin()+50000);
		}

		if (ns==1){
			if (!wave.empty()) nOme = find_Ome_fourier((int)wave.size(), wave, dt, no_fourier_dump());

			else               nOme = 0.;
		}

		if (nOme>1.)  nOme=nOme-2*pi;
		if (nOme<-1.) nOme=nOme+2*pi;

		wave.clear();

		// --- cleanup ---------------------------------------------------------
		free_matrix(A, Nsys);
		free_vec(B);
		free_pcfc();

		delete[] q;
		delete[] odv;
		delete[] nv;

		return aj;
	}

inline std::complex<double> nanosphere::analytical(int order, char* mdl , char* mtl ,char* hst,
									double E0, double omeeV, double T, double tpump,
									char* sol, double rho){
		constexpr int Nsys = 5;

		double eps_b, eps_s, ome, dt, dnormem=1.e20, tildeN;
		int ns=0;
		if (sol != NULL) { eps_s=set_host(sol); ns=1; }
		else             { eps_s=0; }

		eps_b=set_host(hst);
		int steste=0, amp=0;

		std::complex<double> eps1e, eps2e, eps1, eps2, alph, m, x, k,
							*p=nullptr, *p0=nullptr, *p1=nullptr, *p2=nullptr, *p3=nullptr, n1, n2;

		double omep, t, t_ps, tau2, gamd, ome_g, pG = fabs(G), *nv=nullptr, lam;

		std::complex<double> GamGxN, OmeG, chiH,
							GamM, OmeM, chiP, **A=nullptr, *B=nullptr, aj, *odv=nullptr;

		std::complex<double> *q=nullptr, *qss=nullptr, *kap=nullptr, **EVE=nullptr, *C=nullptr;

		if (T==0){ T=100000; steste=1; }

		std::ostringstream fncname, aj_name;
		fncname << "../data/output/anl/func" << std::setw(2) << std::setfill('0') << order << ".dat";
		aj_name << "../data/output/anl/a"    << std::setw(2) << std::setfill('0') << order << ".dat";

		std::ofstream fnct(fncname.str());
		std::ofstream a_aj(aj_name.str());
		std::ofstream dyna;

		if(order==1){
			dyna.open("../data/output/anltime.dat");
			dyna<<"# * ANALYTICAL *\n#\n# file generated by ** cupN.H **\n#\n";
			dyna<<"# PARAMETERS:\n";
			dyna<<"# G = "<<pG<<" a = "<<this->a<<"\n";
			dyna<<"# ome = "<<omeeV<<" eV\n";
			dyna<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
			dyna<<"# -------------\n";
			dyna<<"# t (ps)\treal(alph)\timag(alph)\n#\n";
		}

		fnct<<"# * ANALYTICAL *\n#\n# file generated by ** cupN.H **\n#\n";
		fnct<<"# PARAMETERS:\n";
		fnct<<"# G = "<<pG<<" a = "<<this->a<<"\n";
		fnct<<"# ome = "<<omeeV<<" eV\n";
		fnct<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
		fnct<<"# -------------\n";
		fnct<<"# t (ps)\treal(q0)\timag(q0)\treal(q1)\timag(q1)\treal(q2)\timag(q2)\treal(q4)\timag(q4)\n#\n";

		a_aj<<"# * ANALYTICAL *\n#\n# file generated by ** cupN.H **\n#\n";
		a_aj<<"# PARAMETERS:\n";
		a_aj<<"# G = "<<pG<<" a = "<<this->a<<"\n";
		a_aj<<"# ome = "<<omeeV<<" eV\n";
		a_aj<<"# a "<<mdl<<" model was used for "<<mtl<<"\n";
		a_aj<<"# -------------\n";
		a_aj<<"# t (ps)\treal(a"<<order<<")\timag(a"<<order<<")\n#\n";

		// --- helpers ---------------------------------------------------------
		auto free_matrix = [&](std::complex<double>**& M, int n){
			if (!M) return;
			for (int i=0;i<n;++i) delete[] M[i];
			delete[] M;
			M=nullptr;
		};
		auto free_vec = [&](std::complex<double>*& v){
			delete[] v;
			v=nullptr;
		};
		auto free_pcfc = [&](){
			delete[] p0; p0=nullptr;
			delete[] p1; p1=nullptr;
			delete[] p2; p2=nullptr;
			delete[] p3; p3=nullptr;
			p=nullptr;
		};
		auto rebuild_medium = [&](double Nnow){
			GamGxN = set_GamG(G*Nnow, tau2);
			chiH   = -GamGxN/OmeG;
			eps2e  = eps_b + chiH;
			eps2   = eps2e;

			n2 = sqrt(eps2e);
			m  = n1/n2;

			k = 2.*M_PI*n2/lam;
			x = k;

			free_pcfc();
			p0 = pcfc0(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p1 = pcfc1(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p2 = pcfc2(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);
			p3 = pcfc3(order, x, m, ceps_inf, eps_b, GamGxN, OmeG, GamM, OmeM, ome, eps_s, rho);

			p = (ns==1) ? p3 : p0;
		};

		auto rebuild_linear_system = [&](){
			// free old A,B,qss,kap,EVE,C
			free_matrix(A, Nsys);
			free_vec(B);
			free_vec(qss);
			free_vec(kap);
			free_evec(EVE, Nsys); EVE=nullptr;
			free_vec(C);

			A   = coefficients(OmeG, OmeM, GamGxN, GamM, p0, p1, p2, p3);
			B   = inhomogeneous(GamGxN, GamM, E0, p0, p1, p2, p3);
			qss = steady_state_solution(A, B, Nsys);

			// paired eigen decomposition (kap + EVE consistent!)
			eigen_decomposition(A, kap, EVE, Nsys);
		};

		// --- setup -----------------------------------------------------------
		omep = eV2j*Ome_p/h;  // Hz

		nv   = normalized_variables();
		tau2 = nv[1];
		gamd = nv[2];
		ome_g = nv[3];

		ome = omeeV/Ome_p;

		odv  = set_ome_dep_vrbls(ome, ome_g, tau2, gamd);
		OmeG = odv[0];
		OmeM = odv[1];
		GamM = odv[2];

		// metal part
		eps1  = metal(omeeV);
		chiP  = -GamM/OmeM;
		eps1e = ceps_inf + chiP;
		n1    = sqrt(eps1e);

		lam = h*cc/(omeeV*eV2j);
		lam = lam/(this->a*1.e-9);

		// time normalization
		T  = T*omep*1.e-12;
		dt = 1.;

		q = new std::complex<double>[Nsys]{};

		int Nt = static_cast<int>(T/dt);
		int Nprint_max = 500000;
		int iprint = std::max(1, Nt / Nprint_max);

		// start: no pump
		tildeN = 0.0;
		double N = tildeN;

		rebuild_medium(N);
		rebuild_linear_system();
		C = find_constants(EVE, qss, q, Nsys);

		double t0 = 0.0;
		int i=0, pip=0;

		while(i<=Nt){
			t=i*dt;
			t_ps = t * 1.e+12 / omep; // time in picoseconds
			++i;

			if(t_ps >= tpump && pip==0){
				// snapshot state
				std::complex<double> q_at_t0[Nsys];
				for(int ii=0; ii<Nsys; ++ii) q_at_t0[ii] = q[ii];

				tildeN = 1.0;
				N      = tildeN;
				t0     = t;
				pip    = 1;

				rebuild_medium(N);
				rebuild_linear_system();

				// constants MUST match this EVE/qss
				C = find_constants(EVE, qss, q_at_t0, Nsys);

				amp = 0;
				for(int ei=0; ei<Nsys; ++ei){
					if (kap[ei].real() > 0) { amp=1; break; }
				}
			}

			// closed form evolution
			for(int ii=0; ii<Nsys; ++ii){
				std::complex<double> s = qss[ii];
				for(int ei=0; ei<Nsys; ++ei)
					s += C[ei]*EVE[ii][ei]*exp(kap[ei]*(t-t0));
				q[ii] = s;
			}

			dnormem = steste*norm(aj);
			aj = numerical_output(E0, q, p)/E0;

			if(order==1) alph = polarizability(aj, eps2e, lam);
			else         alph = {0,0};

				if(i%iprint==0){
					if(order==1)
						dyna<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
							<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(alph)
							<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(alph)
							<<"\n";

					a_aj<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(aj)
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(aj)
						<<"\n";

					fnct<<"  "<<std::setw(8)<<std::setiosflags(std::ios::left)<<t_ps
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[0])
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[0])
						<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[1])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[1])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[2])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[2])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[3])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[3])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<real(q[4])
					<<"\t"<<std::setw(13)<<std::setiosflags(std::ios::left)<<imag(q[4])
					<<"\n";
			}

			if (amp==1 && norm(aj)/E0 > 5.e26 && steste==1) break;

			if (amp==0 && t_ps > 2.*tpump)
				if (fabs((norm(aj)-dnormem)/norm(aj)) < 1.e-20 && steste==1) break;
		}

		// --- cleanup ---------------------------------------------------------
		free_matrix(A, Nsys);
		free_vec(B);
		free_vec(qss);
		free_vec(kap);
		free_evec(EVE, Nsys); EVE=nullptr;
		free_vec(C);

		free_pcfc();

		delete[] q;
		delete[] odv;
		delete[] nv;

		return aj;
	}
